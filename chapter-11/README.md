# オブザーバビリティとモニタリングに触れてみる

## オブザーバビリティについて

システムが「観測可能である」状態にするにはどうすれば良いか。

CNCFのホワイトペーパーではシステムの出力シグナルと呼び、好みのシグナルを一つ使うところから始めると良い、と書かれている。シグナルは3つのプライマリシグナルと二つの新規シグナルが紹介されており、プライマリシグナルから使うと良いとも書かれている。

3つのプライマリシグナル

1. Logs
2. Metrics
3. Traces

2つの新規シグナル

1. Profiles
2. Dumps

### 情報を収集する：Logs

Kubernetesではデフォルトでログを収集する仕組みがある。コンテナの標準出力/エラー（Stdout/Stderr）の内容をコンテナのログとして収集する。これまで`kuberctl logs`を使ってきたと思うが、これはKubernetesのデフォルトにあるログ収集の仕組みを使っている。

しかし、このデフォルトの仕組みを利用したログはPodがNodeから削除されると消えてしまう。そのため、本番運用を行うにあたってログを永続化する仕組みを入れる必要がある。KubernetesのPersisstent Volumesを利用して保存しておいても良いが、外部に転送して保存しておくこともできる。

ログを外部に転送するためによく利用されるのは、FluentdやFluentbitがある。また、ログを収集・検索可能にするOSSとしてGrafana Lokiが挙げられる。

### 測定値を処理する:Metrics

メトリクスは測定値の集合である。測定を利用した投擲的な処理をしたり、傾向を見たい場合に活用できたりする。ログは多くの情報を取得できるが、その分データ容量が必要になる。また、「一日に何件アクセスがあったか」を調べるためにログファイルを開いて件数を数えるのはあまり現実的ではない。そこで必要になるのがメトリクスである。

メトリクスもログ同様にクラウドベンダー標準機能を利用することもできるが、さらなる高機能を求めて外部クラウドサービスを利用するケースも多く見られる。Kubernetesは標準でメトリクスを収集する機能はない。そのため、メトリクスを収集するためには外部サービスを利用する必要がある。

メトリクスを収集するためによく利用されるOSSにPrometheusが挙げられる。独自のPromQLというクエリ言語を利用して収取したメトリクスを参照することが可能。

### 通信を追跡する:Traces

 Traces（分散トレーシング）はユーザー内しアプリの通信を追跡するための概念。また、Tracesは複数のSpan（操作の集合）から成る。コンテナを複数稼働させている状況で環境障害が発生した時、ユーザーからのリクエストがどのコンテナを経由したかを正確に辿る必要が出てきた時に利用できる。

 また、Tracesを導入することで「どのリクエストにどれくらい時間がかかったか」を細かく可視化できるので、パフォーマンス改善・チューニングにも利用できる。

しかし、これまでのログやメトリクスと異なり、どこかのコンポーネント・インフラだけがトレーシングを実現しているのでは意味がない。正確にアクセスを追跡するためには、リクエストが通る経路上の全てでTraces/Spanが導入できている必要がある。そのため、ログやメトリクスに比べて導入のハードルは高いかもしれない。

Tracesを導入するためにはアプリケーションの実装に手を入れる必要がある。どこからどこまでのリクエストをTracesとして扱い、Spanとして扱うか。これらを考えた上でTraces/Spanを表現する実装を入れる必要がある

Tracesを導入するためにアプリケーションで実装を追加する必要があるが、実装を簡易化するためのOSSライブラリがある。

![OpenTelemetry](https://opentelemetry.io/)といい、Traces以外にもメトリクスやログなどのデータの標準仕様を定めたり、ツールを提供していたりするCNCFのプロジェクトである。

また、実装したTracesを収集する代表的なOSSとして、![Jaeger](https://www.jaegertracing.io/)や![Grafana Tempo](https://grafana.com/oss/tempo/)が挙げられる。

## モニタリングについて

### 情報を可視化する：ダッシュボード

オブザーバビリティはデータを収集しただけでは実現できない。観測できるようにするためには、可視化をする必要がある。とくにMetricsやTracesはある一点のデータだけでわかることは少なく、全体や、ある一定の時間軸の中で見ていくことが大事でさる。可視化をするために、ダッシュボードを作成する。障害調査に利用するだけでなく、障害を起こさないために、あるいは性能劣化や異常を見つけるために利用する。

### 異常を知らせる：アラート

観測可能な状態ができたら、異常が起きたことがわかるように、アラートの設定も行う。アラートにはMetricsを使うと良いだろう。アラートの設定の仕方、監視をするためのノウハウに関しては一つの本が出ているくらいさまざまなものがある。ダッシュボードで観測できた値を基にまずは設定してみて、継続的に改善していくと良い。

## モニタリング用システム構築

ここではPrometheus、そしてGrafanaを使ってモニタリング用のシステムを構築してみる。

### Prometheus/Grafanaをインストールする

`kubectl get pod --namespace monitoring`を実行し、すべてのPodがRunningになっていることを確認する。

```zsh
> kubectl get pod --namespace monitoring
NAME                                                        READY   STATUS    RESTARTS        AGE
alertmanager-kube-prometheus-stack-alertmanager-0           2/2     Running   8 (3h6m ago)    16d
kube-prometheus-stack-grafana-76b485bc4c-dqq92              3/3     Running   12 (3h6m ago)   16d
kube-prometheus-stack-kube-state-metrics-7db65fb76b-bhq6m   1/1     Running   8 (3h6m ago)    16d
kube-prometheus-stack-operator-7566b999fc-bxgml             1/1     Running   8 (3h6m ago)    16d
kube-prometheus-stack-prometheus-node-exporter-bsw9h        1/1     Running   4 (3h6m ago)    16d
prometheus-kube-prometheus-stack-prometheus-0               2/2     Running   8 (3h6m ago)    16d
```

### メトリクスを収集するアプリケーションを起動する

オブザーバビリティはObserveする対象が存在して初めて成り立つ。ということで、まずはアプリを立ち上げよう。これまでにも登場したhello-serverアプリを使う。これまでと一点だけ異なるのは、メトリクス用のエンドポイントを追加することだ。

Prometheusは`/metrics`というエンドポイントに対してアクセスし、メトリクスを収集する。`/metrics`でどのようなメトリクスを収集可能にするかはアプリケーション開発者の自由である。今回はPrometheusのGo用ライブラリを利用し、Goに関連するメトリクスを収集可能にする。

実装は次のとおりライブラリの追加と、metricsエンドポイントの追加のみ。
