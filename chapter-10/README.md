# K8sの開発ワークフローを利用する

## Kubernetesにデプロイする

これまでのハンズオンでK8sにデプロイするために`kubectl apply --file name`を実施してきたが、継続的にデプロイするためには次の課題がある。

- いつ誰がコマンドを実施したかわからない
- コマンドの実施により、マニフェストの衝突が起きてしまう
- 毎回手動で実施するのでは、手間がかかる。さらにヒューマンエラーも起きやすい

この課題を解決するためのデプロイ手法として、K8sを利用するケースでは大きく分けてCIOpsとGitOpsがある。いずれもGitHubなど共有リポジトリを利用することでマニフェストの衝突・差分の管理を行なっている。

### Push型のデプロイ方法: CIOps

`kubectl apply --filename <fileName>`を自動化しようとした時に、例えば「mainブランチにfeatureブランチがマージされたら本番環境にkubectl applyを実行する」ようなケースが最初に思いつく。この自動化はCIツールで実行すると思うが、これをCIOpsと呼ぶ。

CIOpsはわかりやすく、かつ実現しやすい手法である。デメリットとしてCI/CD用のツールに強い権限が必要であることや、デプロイ用のスクリプトが長く複雑になりがちということが挙げられる。

### Pull型のデプロイ方法： GitOps

Gitを使っていれば、GitOpsなのでは、と誤解されることも多いが、Gitは直接関係ない。具体的には次の4つの定義に基づいている。

1. 宣言的：システム全体は宣言的に記述される必要がある。
2. バージョン管理と不変：正規望ましいシステムの状態はバージョン管理されている。
3. 自動的に取得：承認された変更はシステムに自動的に適用される
4. 継続的な調整：ソフトウェアエージェントが正確さを保証し、乖離があった場合にアラートを出す。

ここではKubernetesのワークフローを実装するにあたって、大事なポイントを説明する。

多くの開発者はCIOpsから入ると思うが、GitOpsを選択する理由はなんだろうか。4つの定義のうち「3.自動的に取得（原文：Pulled automatically）」がCIOpsとGitOpsの大きな違いの一つである。よく「Push型」「Pull型」と言われるが、CIOpsがPush型で、GitOpsがPull型である。その名の通り、Push操作が行われたタイミングで動作するのがPush型、一定間隔で対象をPullし、動作する必要がある内容をPullしたタイミングで動作するのがPull型である。Pull型であることで、次のようなメリットを得られる。

#### メリット１：セキュリティリスクを低減できる

K8sクラスタにマニフェストを適用するという性質上、書き込み権限が必要になる。このため、書き込み権限を持つ認証情報が盗まれたり、CIが乗っ取られたりする場合は読み書きが可能になってしまうということになる。GitOpsはPull型という性質上、読み取り権限さえあれば実現可能である。認証情報が盗まれたとしても、書き込み権限が無い分、CIOpsよりは被害が抑えられるだろう。

#### メリット２：CIとCDが分離できる

CIOpsではCIもCDもCIツールを用いるため、実行タイミング・実行スクリプトなどが一緒になってしまうこともある。サービスやデプロイの単位・範囲が地裁時は特に問題に感じないかもしれないが、規模が大きくなってくると、「CIが重くてデプロイが遅い」「CI＆CDスクリプトが長大になり、メンテナンスができない」という状態になってしまうことがある。GitOpsでは専用のデプロイツールを利用し、さらにデプロイの情報を宣言的に管理することでCIと分離することが可能。

また、これはメリット１にも通じる話だが、CIとCDが分離できるので、CI用の権限を持つ人（ツール）とCD用の権限を持つ人（ツール）を分けて管理できるようになる。

これらのメリットはどんな環境でも享受できるわけではない。特に小さい規模でK8sを利用している場合、メリットよりもデメリットが大きくなるだろう。とはいえ、いつか規模が大きくなることを見越してGitOpsについて知っておくと良いだろう。

GitOpsは概念だが、ではどのようにしてワークフローに組み込むのだろうか？GitOpsを実現するためのソフトウェアがいくるかOSSとして公開されている。

#### Argo CD

`https://argoproj.github.io/cd/`

Argo CDではApplicationという名前のCustom Resourceを利用し、「どのリポジトリの」「どのマニフェストの」「どのバージョン（例：ブランチ）の」マニフェストを「どの環境に」適用するかを指定します。

#### Spinnaker

`https://spinnaker.io/`

SpinnakerはKubernetes以外にも、主要なクラウドプロバイダに対応していることを売りにしている。そのため、Argo CDはKubernetesクラスタへのデプロイのみを扱うが、SpinnakerではDocker ImageのビルドなどCIパイプラインの構築もできる。

#### FluxCD

`https://fluxcd.io/`

Argo CDとかなり近いが、v2になってマルチテナンシーが違い。

## Kubernetesのマニフェスト管理







